<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="custom-assembling-system">Custom assembling system</h1>
<h2 id="context">Context</h2>
<p><em>Disclaimer: Github’s markdown may not render properly LaTeX equations of this readme, so, please, take a look at its <code>.pdf</code> version. Otherwise, we advise you to download the <code>.md</code> file and render it locally on your machine.</em></p>
<p>We consider the following typical non-linear problem in our study:</p>
<p>Find $\underline{u} \in V$, such that</p>
<p>$$ F(\underline{u}) = \int_\Omega \underline{\underline{\sigma}}(\underline{u}) : \underline{\underline{\varepsilon}}(\underline{v}) dx - \int_\Omega \underline{f} \underline{v} dx = 0 \quad \forall \underline{v} \in V,$$
where an expression of $\underline{\underline{\sigma}}(\underline{u})$ is non linear and cannot be defined via UFL. Let us show you some examples</p>
<ul>
<li>$\underline{\underline{\sigma}}(\underline{u}) = f(\varepsilon_\text{I}, \varepsilon_\text{II}, \varepsilon_\text{III})$,</li>
<li>$\underline{\underline{\sigma}}(\underline{u}) = \underset{\alpha}{\operatorname{argmin}} g(\underline{\underline{\varepsilon}}(\underline{u}),  \alpha)$,</li>
</ul>
<p>where $\ \varepsilon_\text{I}, \varepsilon_\text{II}, \varepsilon_\text{III} $ are eigenvalues of $\ \underline{\underline{\varepsilon}} $ and $\ g$ some scalar function.</p>
<p>As seen in the second example, $\ \underline{\underline{\sigma}}(\underline{u}) $ can also implicitly depend on the value of other scalar, vector or even tensorial quantities, $\ \alpha $ here. The latter do not necessarily need to be represented in a finite-element function space. They shall just be computed during the assembling procedure when evaluating the expression $\ \underline{\underline{\sigma}}(\underline{u}) $ pointwise.</p>
<p>In addition, in order to use a standard Newton method to find the solution of $\ F(\underline{u})=0 $, we also need to compute the derivative of $\ \underline{\underline{\sigma}} $ with respect to $\ \underline{u} $. The latter may also depend on some internal variables $\ \alpha $ of $\ \underline{\underline{\sigma}} $. Thus, it is necessary to have a fonctionality which will allow to do a simultaneous calculation of $\ \underline{\underline{\sigma}}$ and its derivative during assembling procedure.</p>
<p>In practice, in the previous examples $\ \underline{\underline{\sigma}} $ depends directly on $\ \underline{\underline{\varepsilon}} = \frac{1}{2}(\nabla \underline{u} + \nabla \underline{u}^T) $. As a result, it is more natural to consider the non-linear expression as a function of $\ \underline{\underline{\varepsilon}} $ directly, provide an expression for $\ \dfrac{d\underline{\underline{\sigma}}}{d\underline{\underline{\varepsilon}}} $ and evaluate $\ \dfrac{d\underline{\underline{\sigma}}}{d\underline{u}} $ by the chain rule (letting UFL handle the $\ \dfrac{d\underline{\underline{\varepsilon}}}{d\underline{u}} $ part).</p>
<p>As the result we require the following features:</p>
<ol>
<li>To define nonlinear expressions of variational problems in more complex way than it's allowed by UFL</li>
<li>To let an &quot;oracle&quot; provide values of such an expression and its derivative(s)</li>
<li>To call this oracle on-the-fly during the assembly to avoid unnecessary loops, precomputations and memory allocations</li>
</ol>
<p>The following text describes our own view of these features implementation.</p>
<h2 id="custom-assembling">Custom assembling</h2>
<p>Following the concept of the <a href="https://github.com/FEniCS/dolfinx/blob/main/python/test/unit/fem/test_custom_assembler.py">custom assembler</a>, which uses the power of <code>numba</code> and  <code>cffi</code> python libraries, we implemented our own version of custom assembler, where we can change the main loop of the assembling procedure.</p>
<!-- There are several essential elements of the algorithm to be mentioned. First of all,  -->
<h2 id="customfunction">CustomFunction</h2>
<p>We would like to introduce a concept of <code>CustomFunction</code> (for lack of a better name), which is essential for our study. Let us consider the next simple variational problem</p>
<p>$$ \int_\Omega g \cdot uv dx, \quad \forall \underline{v} \in V, $$</p>
<p>where $\ \underline{u} $ is a trial function, $\ \underline{v} $ is a test function and the function $\ g $ is an expression. For this moment we must use <code>fem.Function</code> class to implement this variational form. Knowing the exact UFL expression of $\ g $ we can calculate its values on every element using the interpolation procedure of <code>fem.Expression</code> class. So we save all values of $\ g $ in one global vector. The goal is to have a possibility to calculate $\ g $ expression, no matter how difficult it is, in every element node (for instance, in every gauss point, if we define $\ g $ on a quadrature element) during the assembling procedure.</p>
<p>We introduce a new entity named as <code>CustomFunction</code> (or <code>CustomExpression</code>). It</p>
<ol>
<li>inherits <code>fem.Function</code></li>
<li>contains a method <code>eval</code>, which will be called inside of the assemble loop and calculates the function local values</li>
</ol>
<h2 id="dummyfunction">DummyFunction</h2>
<p>Besides <code>CustomFunction</code> we need an other entity. Every <code>fem.Function</code> object stores its values globally, but we would like to avoid such a waste of memory updating the function value during the assembling procedure. Let us consider the previous variational form, where $\ g $ contains its local-element values now. If there is one local value of $\ g $ (only 1 gauss point), $\ g $ will be  <code>fem.Constant</code>, but we need to store different values of $\ g $ in every element node (gauss point). So we introduce a concept of <code>DummyFunction</code> (or <code>ElementaryFunction</code>?), which</p>
<ol>
<li>inherits <code>fem.Function</code></li>
<li>allocates the memory for local values only</li>
<li>can be updated during assembling procedure</li>
</ol>
<h2 id="examples">Examples</h2>
<p>We implemented elasticity and plasticity problems to explain our ideas by examples.</p>
<h3 id="elasticity-problem">Elasticity problem</h3>
<p>Let's consider a beam stretching with the left side fixed. On the other side we apply displacements. Find $\underline{u} \in V$ s.t.</p>
<p>$$\int_\Omega \underline{\underline{\sigma}}(\underline{\underline{\varepsilon}}(\underline{u})) : \underline{\underline{\varepsilon}}(\underline{v}) d\underline{x}  = 0 \quad \forall \underline{v} \in V,$$</p>
<p>$$ \partial\Omega_\text{left} : u_x = 0, $$
$$ (0, 0) : u_y = 0, $$
$$ \partial\Omega_\text{right} : u_x = t \cdot u_\text{bc},$$
where $\ u_\text{bc} $ is a maximal displacement on the right side of the beam, $\ t $ is a parameter varying from 0 to 1, and where $\ \underline{\underline{\sigma}}(\underline{\underline{\varepsilon}}) $ is our user-defined &quot;oracle&quot;. Here we use a simple elastic behaviour:</p>
<p>$$
\underline{\underline{\sigma}}(\underline{\underline{\varepsilon}}) = \mathbf{C}:\underline{\underline{\varepsilon}}
$$</p>
<p>and for which the derivative is:</p>
<p>$$
\dfrac{d\underline{\underline{\sigma}}}{d\underline{\underline{\varepsilon}}} = \mathbf{C}
$$</p>
<p>where $\mathbf{C}$ is the stiffness matrix.</p>
<p>Let's focus on the key points. In this &quot;naive&quot; example the derivative is constant, but in general non-linear models, it's value will directly depend on the local value of $\ \underline{\underline{\varepsilon}} $. We would like to change this value at every assembling step. In our terms, it is a <code>DummyFunction</code>. Obviously, $\ \underline{\underline{\sigma}} $ is the <code>CustomFunction</code>, which depends on $\ \underline{\underline{\varepsilon}} $.</p>
<pre class="hljs"><code><div>q_dsigma = ca.DummyFunction(VQT, name=<span class="hljs-string">'stiffness'</span>) <span class="hljs-comment"># tensor C</span>
q_sigma = ca.CustomFunction(VQV, eps(u), [q_dsigma], get_eval)  <span class="hljs-comment"># sigma^n</span>
</div></code></pre>
<p>In the <code>CustomFunction</code> constructor we observe three arguments. The first one is the UFL-expression of its variable $\ \underline{\underline{\varepsilon}}$ here. It will be compiled via ffcx and will be sent as &quot;tabulated&quot; expression to a numba function, which performs the calculation of <code>q_sigma</code>. The second argument is a list of <code>q_sigma</code> coefficients (<code>fem.Function</code> or <code>DummyFunction</code>), which take a part in calculations of <code>q_sigma</code>. The third argument contains a function generating a <code>CustomFunction</code> method <code>eval</code>, which will be called during the assembling. It describes every step of local calculation of $\ \underline{\underline{\sigma}} $.</p>
<p>Besides the local implementation of new entities we need to change the assembling procedure loop to describe explicitly the interaction between different coefficients of linear and bilinear forms. It allows us to write a quite general custom assembler, which will work for any kind non-linear problem. Thus we have to define two additional numba functions to calculate local values of forms kernels coefficients (see the code below).</p>
<pre class="hljs"><code><div><span class="hljs-meta">@numba.njit(fastmath=True)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">local_assembling_b</span><span class="hljs-params">(cell, coeffs_values_global_b, coeffs_coeff_values_b, coeffs_dummy_values_b, coeffs_eval_b, u_local, coeffs_constants_b, geometry, entity_local_index, perm)</span>:</span>
    sigma_local = coeffs_values_global_b[<span class="hljs-number">0</span>][cell]
    
    output_values = coeffs_eval_b[<span class="hljs-number">0</span>](sigma_local, 
                                     u_local, 
                                     coeffs_constants_b[<span class="hljs-number">0</span>], 
                                     geometry, entity_local_index, perm)

    coeffs_b = sigma_local

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(coeffs_dummy_values_b)):
        coeffs_dummy_values_b[i][:] = output_values[i] <span class="hljs-comment">#C update</span>

    <span class="hljs-keyword">return</span> coeffs_b

<span class="hljs-meta">@numba.njit(fastmath=True)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">local_assembling_A</span><span class="hljs-params">(coeffs_dummy_values_b)</span>:</span>
    coeffs_A = coeffs_dummy_values_b[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">return</span> coeffs_A
</div></code></pre>
<h3 id="plasticity-problem">Plasticity problem</h3>
<p>The elasticity case is trivial and doesn't show clearly our demands by the described above features. Therefore we present here a standard non-linear problem from our scientific domain - a plasticity one.</p>
<p>The full description of the problem and its implementation on a legacy version of Fenics is introduced <a href="https://comet-fenics.readthedocs.io/en/latest/demo/2D_plasticity/vonMises_plasticity.py.html">here</a>. Note that for this very specific example, everything can still be expressed in UFL directly. However, in general, this is no longer the case, as one may have to solve a nonlinear equation at each integration point to obtain the expression of stresses and plasticity variables.</p>
<p>We focus on the following variational problem only: Find $\underline{\Delta u} \in V$ s.t.</p>
<p>$$ \int\limits_\Omega \underline{\underline{\sigma_{n+1}}} (\underline{\underline{\varepsilon}}(\underline{\Delta u})) : \underline{\underline{\varepsilon}}(\underline{v}) dx - q \int\limits_{\partial\Omega_{\text{inside}}} \underline{n} \cdot \underline{v} dx = 0, \quad \forall \underline{v} \in V, $$</p>
<p>where $\ \underline{\Delta u} $ is a displacement increment between two load steps, $\ \underline{\underline{\sigma}}_{n+1} $ is the current stress tensor which depends on the previous stress $\ \underline{\underline{\sigma}}_n $ and the previous plastic strain $\ p_n $ and which is implicitly defined as the solution to the following equations:</p>
<p>$$\underline{\underline{\sigma_\text{elas}}} = \underline{\underline{\sigma}}<em>n + \mathbf{C} : \underline{\underline{\Delta\varepsilon}}, \quad \sigma^\text{eq}</em>\text{elas} = \sqrt{\frac{3}{2} \underline{\underline{s}} : \underline{\underline{s}}}$$</p>
<p>$$\underline{\underline{s}} = \mathsf{dev} , \underline{\underline{\sigma_\text{elas}}} $$</p>
<p>$$ f_\text{elas} = \sigma^\text{eq}_\text{elas} - \sigma_0 - H p_n $$</p>
<p>$$\Delta p = \frac{&lt; f_\text{elas} &gt;_+}{3\mu + H},$$</p>
<p>$$\beta = \frac{3\mu}{\sigma^\text{eq}_\text{elas}}\Delta p$$</p>
<p>$$\underline{\underline{n}} = \frac{\underline{\underline{s}}}{\sigma^\text{eq}_\text{elas}}$$</p>
<p>$$\underline{\underline{\sigma}}<em>{n+1} = \underline{\underline{\sigma</em>\text{elas}}} - \beta \underline{\underline{s}}$$</p>
<p>$$
&lt; f&gt;_+ =
\begin{cases}
f, \quad f &gt; 0, \
0, \quad \text{otherwise}
\end{cases}
$$</p>
<p>where $\ \underline{\underline{\Delta\varepsilon}} = \underline{\underline{\varepsilon}}(\underline{\Delta u}) $ is the total strain increment.</p>
<p>The corresponding derivative of the non-linear expression $\ \underline{\underline{\sigma}}_{n+1}(\underline{\underline{\Delta\varepsilon}}) $ is given by:</p>
<p>$$\dfrac{d\underline{\underline{\sigma}}_{n+1}}{d\underline{\underline{\Delta\varepsilon}}} = \mathbf{C}^\text{tang}(\underline{\underline{\Delta\varepsilon}}) = \mathbf{C} - 3\mu \left( \frac{3\mu}{3\mu + H} -\beta \right) \underline{\underline{n}} \otimes \underline{\underline{n}} - 2\mu\beta \mathbf{DEV} $$</p>
<p>In contrast to the elasticity problem the tangent stiffness depends here on $\ \underline{\underline{\Delta\varepsilon}} $ and has different values in every gauss point. Since it's value is needed only for computing the global jacobian matrix, we would like to avoid an allocation of such a global tensorial field. This justifies to use the concept of <code>DummyFunction</code> for $\ \mathbf{C}^\text{tang} $.</p>
<p>We can conclude, that the fields $\ \underline{\underline{\sigma_{n+1}}} = \underline{\underline{\sigma_{n+1}}}(\underline{\underline{\Delta\varepsilon}}, \beta, \underline{\underline{n}}, dp, p_n, \underline{\underline{\sigma_n}}) $ and $\ \mathbf{C}^\text{tang} = \mathbf{C}^\text{tang}(\beta, \underline{\underline{n}}) $ depend on the common variables $\ \beta $ and $\ \underline{\underline{n}} $. With the legacy implementation, it was necessary to allocate additional space for them and calculate $\ \underline{\underline{\sigma_{n+1}}} $ and $\ \mathbf{C}^\text{tang} $ separately, but now we can combine their local evaluations.</p>
<p>In comparison with the elasticity case the <code>CustomFunction</code> <code>sig</code> has more dependent fields. Look at the code below</p>
<pre class="hljs"><code><div>C_tang = ca.DummyFunction(QT, name=<span class="hljs-string">'tangent'</span>) <span class="hljs-comment"># tensor C_tang</span>
sig = ca.CustomFunction(W, eps(Du), [C_tang, p, dp, sig_old], get_eval) <span class="hljs-comment"># sigma_n</span>
</div></code></pre>
<p>As it was expected, the local evaluation of the <code>CustomFunction</code> becomes more complex</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_eval</span><span class="hljs-params">(self:ca.CustomFunction)</span>:</span>
    tabulated_eps = self.tabulated_input_expression
    n_gauss_points = len(self.input_expression.X)
    local_shape = self.local_shape
    C_tang_shape = self.tangent.shape

<span class="hljs-meta">    @numba.njit(fastmath=True)</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eval</span><span class="hljs-params">(sigma_current_local, sigma_old_local, p_old_local, dp_local, coeffs_values, constants_values, coordinates, local_index, orientation)</span>:</span>
        deps_local = np.zeros(n_gauss_points*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>, dtype=PETSc.ScalarType)
        
        C_tang_local = np.zeros((n_gauss_points, *C_tang_shape), dtype=PETSc.ScalarType)
        
        sigma_old = sigma_old_local.reshape((n_gauss_points, *local_shape))
        sigma_new = sigma_current_local.reshape((n_gauss_points, *local_shape))

        tabulated_eps(ca.ffi.from_buffer(deps_local), 
                      ca.ffi.from_buffer(coeffs_values), 
                      ca.ffi.from_buffer(constants_values), 
                      ca.ffi.from_buffer(coordinates), ca.ffi.from_buffer(local_index), ca.ffi.from_buffer(orientation))
        
        deps_local = deps_local.reshape((n_gauss_points, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>))

        n_elas = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), dtype=PETSc.ScalarType) 
        beta = np.zeros(<span class="hljs-number">1</span>, dtype=PETSc.ScalarType) 
        dp = np.zeros(<span class="hljs-number">1</span>, dtype=PETSc.ScalarType) 

        <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> range(n_gauss_points):
            sig_n = as_3D_array(sigma_old[q])
            sig_elas = sig_n + sigma(deps_local[q])
            s = sig_elas - np.trace(sig_elas)*I/<span class="hljs-number">3.</span>
            sig_eq = np.sqrt(<span class="hljs-number">3.</span>/<span class="hljs-number">2.</span> * inner(s, s))
            f_elas = sig_eq - sig0 - H*p_old_local[q]
            f_elas_plus = ppos(f_elas)
            dp[:] = f_elas_plus/(<span class="hljs-number">3</span>*mu_+H)
            
            sig_eq += TPV <span class="hljs-comment"># for the case when sig_eq is equal to 0.0</span>
            n_elas[:,:] = s/sig_eq*f_elas_plus/f_elas
            beta[:] = <span class="hljs-number">3</span>*mu_*dp/sig_eq
      
            new_sig = sig_elas - beta*s
            sigma_new[q][:] = np.asarray([new_sig[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], new_sig[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], new_sig[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], new_sig[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]])
            dp_local[q] = dp[<span class="hljs-number">0</span>]
            
            C_tang_local[q][:] = get_C_tang(beta, n_elas)
        
        <span class="hljs-keyword">return</span> [C_tang_local.flatten()] 
    <span class="hljs-keyword">return</span> eval
</div></code></pre>
<p>Thus it can been seen more clearly the dependance of the tensor $\ \mathbf{C}^\text{tang} $ on the calculation of the tensor $\ \underline{\underline{\sigma}}_{n+1} $.</p>
<h2 id="summarize">Summarize</h2>
<p>We developed our own custom assembler which makes use of two new entities. This allows us to save memory, avoid unnecessary global <em>a priori</em> evaluations and do instead on-the-fly evaluation during the assembly. More importantly, this allows to deal with more complex mathematical expressions, which can be implicitly defined, where the UFL functionality is quite limited. Thanks to <code>numba</code> and <code>cffi</code> python libraries and some FenicsX features, we can implement our ideas by way of efficient code. Our realization doesn't claim to be the most efficient one. So, if you have any comments about it, don't hesitate to share them with us!</p>
<h2 id="miscellaneous">Miscellaneous</h2>
<p>Here you find the table, which contains the time needed to solve the problem and the appropriate JIT overhead.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Mesh</th>
<th style="text-align:center">Time (s)</th>
<th style="text-align:center">Elements nb.</th>
<th style="text-align:center">Nodes nb.</th>
<th style="text-align:center">JIT overhead (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Coarse</td>
<td style="text-align:center">2.7</td>
<td style="text-align:center">1478</td>
<td style="text-align:center">811</td>
<td style="text-align:center">7.5</td>
</tr>
<tr>
<td style="text-align:center">Medium</td>
<td style="text-align:center">14</td>
<td style="text-align:center">5716</td>
<td style="text-align:center">3000</td>
<td style="text-align:center">7.8</td>
</tr>
<tr>
<td style="text-align:center">Fine</td>
<td style="text-align:center">100</td>
<td style="text-align:center">25897</td>
<td style="text-align:center">13251</td>
<td style="text-align:center">4.9</td>
</tr>
</tbody>
</table>
<p>We can conclude from this table, that the time spent on the JIT compilation operations is quite negligible, if we consider dense meshes.</p>

</body>
</html>
